/*******************************************************************************
* Copyright IBM
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/
package com.ibm.biginsights.textanalytics.patterndiscovery.discovery.groupby.analysis;

import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.List;

import au.com.bytecode.opencsv.CSVReader;

import com.ibm.biginsights.textanalytics.patterndiscovery.discovery.groupby.GroupByNewProcessor;
import com.ibm.biginsights.textanalytics.patterndiscovery.discovery.groupby.util.ExperimentProperties;
import com.ibm.biginsights.textanalytics.patterndiscovery.discovery.groupby.util.ExperimentProperties.ParseResult;
import com.ibm.biginsights.textanalytics.patterndiscovery.discovery.groupby.util.PropertyConstants;

/**
 * Performs rule generation as specified in the property file.
 * 
 * 
 * 
 *         Removed legacy code
 * 
 */
public class Correlation2Rules {



	private static final String TYPE_DROP_DEPENDANT = "TYPE_DROP_DEPENDANT";
	private static final String TYPE_DROP_PREDICTOR = "TYPE_DROP_PREDICTOR";
	private static final String TYPE_DROP_MORE_SPECIFIC = "TYPE_DROP_MORE_SPECIFIC";
	private static final String TYPE_DROP_LESS_SPECIFIC = "TYPE_DROP_LESS_SPECIFIC";
	private static final String TYPE_ADD_DEPENDANT = "TYPE_ADD_DEPENDANT";
	private static final String TYPE_ADD_PREDICTOR = "TYPE_ADD_PREDICTOR";
	private static final String TYPE_ADD_MORE_SPECIFIC = "TYPE_ADD_MORE_SPECIFIC";
	private static final String TYPE_ADD_LESS_SPECIFIC = "TYPE_ADD_LESS_SPECIFIC";

	/**
	 * Performs rule generation as specified in the property file. A rule is
	 * generated each pair of sequences if the below conditions apply. In
	 * particular, the following predicates are taken into account:
	 * 
	 * # measure:(pred)measure range for rule generation ruleTypes: What types
	 * of rules are to be generated by Correlation2Rules for cxy and cyx only: -
	 * TYPE_ADD_PREDICTOR (Creates and add rule that will add the independent
	 * variable of the uncertain coefficient if the dependant is found) -
	 * TYPE_DROP_PREDICTOR (Creates and drop rule that will drop the independent
	 * variable of the uncertain coefficient if the both of them are found) -
	 * TYPE_ADD_PREDICTOR (Creates and add rule that will add the dependent
	 * variable of the uncertain coefficient if the independant is found) -
	 * TYPE_DROP_PREDICTOR (Creates and drop rule that will drop the dependent
	 * variable of the uncertain coefficient if the both of them are found) for
	 * the other measures: - TYPE_ADD_MORE_SPECIFIC (creates an add rule that
	 * will add the sequence with the lower relative frequency if that with the
	 * higher is found) - TYPE_ADD_LESS_SPECIFIC (creates an add rule that will
	 * add the sequence with the higher relative frequency if that with the
	 * lower is found) - TYPE_DROP_MORE_SPECIFIC (creates an add rule that will
	 * add the sequence with the lower relative frequency if both sequences are
	 * found) - TYPE_DROP_LESS_SPECIFIC (creates an add rule that will add the
	 * sequence with the higher relative frequency if both sequences are found)
	 * 
	 * measure: only create rule if the correlation measure is in the specified
	 * range e.g. measure: >0.00<1 x relative frequency range. Only generate a
	 * rule, if the relative frequency of the first term is in range e.g.
	 * xRFRange:>0.1 # (pred)y relative frequency range Only generate a rule, if
	 * the relative frequency of the first term is in range yRFRange:>0.1 #
	 * add/dropableCount: only create rule if the count of the add/dropable side
	 * is in this range dropableCount: >0 addableCount: >0 # add/dropableRF:
	 * only create rule if the relative frequency of the add/dropable side is in
	 * this range dropableRF: >0 addableCount: >0 # indicatorCount: only create
	 * rule if the count of the indicator (= non-dropable) side is in this range
	 * indicatorCount: <100 # indicatorRF: only create rule if the relative
	 * frequency of the indicator(=non-dropable) side is in this range
	 * indicatorRF: >0
	 * 
	 * see groupby/data/titles/aqlGroupBy.properties for a commented example
	 * file.
	 * 
	 * @param properties
	 * @param sourceFile
	 * @param targetFile
	 * @param ruleTypes
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	public static void correlation2Rules(ExperimentProperties properties,
			String sourceFile, String targetFile, List<String> ruleTypes)
			throws IOException {

		CSVReader reader = new CSVReader(new InputStreamReader(
				new FileInputStream(sourceFile), GroupByNewProcessor.ENCODING));
		
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(
				new FileOutputStream(targetFile),
				GroupByNewProcessor.ENCODING));
		
		// predicates for absolute and relative counts for indicator and
		// droppable
		ParseResult dropableCountRange = properties
				.parse(properties
						.getProperty(PropertyConstants.DROP_SEQ_COUNT_RANGE) != null ? properties
						.getProperty(PropertyConstants.DROP_SEQ_COUNT_RANGE)
						: ">-1");
		ParseResult dropableRFRange = properties
				.parse(properties
						.getProperty(PropertyConstants.DROP_SEQ_RELATIVE_FREQUENCY_RANGE) != null ? properties
						.getProperty(PropertyConstants.DROP_SEQ_RELATIVE_FREQUENCY_RANGE)
						: ">-1");
		// ParseResult addCountRange =
		// properties.parse(properties.getProperty("addableCount")!=null?properties.getProperty("addableCount"):">-1");
		// ParseResult addRFRange =
		// properties.parse(properties.getProperty("addableRF")!=null?properties.getProperty("addableRF"):">-1");
		ParseResult indicatorCountRange = properties
				.parse(properties
						.getProperty(PropertyConstants.INDICATOR_SEQ_COUNT_RANGE) != null ? properties
						.getProperty(PropertyConstants.INDICATOR_SEQ_COUNT_RANGE)
						: ">-1");
		ParseResult indicatorRFRange = properties
				.parse(properties
						.getProperty(PropertyConstants.INDICATOR_SEQ_RELATIVE_FREQUENCY_RANGE) != null ? properties
						.getProperty(PropertyConstants.INDICATOR_SEQ_RELATIVE_FREQUENCY_RANGE)
						: ">-1");

		String[] line = reader.readNext();
		while (line != null) {
			try {
				int seqX = Integer.parseInt(line[2]);
				int seqY = Integer.parseInt(line[4]);
				// int count = Integer.parseInt(line[5]);
				double distance = Double.parseDouble(line[0]);
				int coCount = Integer.parseInt(line[5]);
				double xRatio = Double.parseDouble(line[6]);
				double yRatio = Double.parseDouble(line[7]);
				int xCount = Integer.parseInt(line[8]);
				int yCount = Integer.parseInt(line[9]);

				int addable;
				int addableCount;
				double addableRatio;
				String addableText;
				int indicatorCount;
				int indicator;
				double indicatorRatio;
				String indicatorText;
				if (ruleTypes.contains(TYPE_DROP_DEPENDANT)
						&& ruleTypes.contains(TYPE_DROP_PREDICTOR)) {
					new RuntimeException("Conflicting rule specifications: "
							+ TYPE_DROP_DEPENDANT + " and "
							+ TYPE_DROP_PREDICTOR);
				}
				// ///////ADDING
				if ((sourceFile.contains("cxy") && ruleTypes
						.contains(TYPE_ADD_DEPENDANT))
						|| (sourceFile.contains("cyx") && ruleTypes
								.contains(TYPE_ADD_PREDICTOR))
						|| ((sourceFile.contains("_mi")
								|| sourceFile.contains("_jc")
								|| sourceFile.contains("_re") || sourceFile
								.contains("_x2")) && ((xRatio < yRatio && ruleTypes
								.contains(TYPE_ADD_LESS_SPECIFIC)) || (yRatio < xRatio && ruleTypes
								.contains(TYPE_ADD_MORE_SPECIFIC))))) {
					addable = seqX;
					addableCount = xCount;
					addableRatio = xRatio;
					indicator = seqY;
					indicatorCount = yCount;
					indicatorRatio = yRatio;
					addableText = line[1];
					indicatorText = line[3];
					if (!checkRanges(properties, dropableCountRange,
							dropableRFRange, indicatorCountRange,
							indicatorRFRange, addableCount, indicatorCount,
							addableRatio, indicatorRatio)) {
						line = reader.readNext();
						continue;
					}
					bw.write(String.format("# ADD %s IF %s\n", addableText,
							indicatorText + " c=" + addableCount, indicatorText
									+ " c=" + indicatorCount + " measure: "
									+ distance + " co-occurrence: " + coCount));
					bw.write(String
							.format("ADD %d IF %d\n", addable, indicator));
				}
				if ((sourceFile.contains("cxy") && ruleTypes
						.contains(TYPE_ADD_PREDICTOR))
						|| (sourceFile.contains("cyx") && ruleTypes
								.contains(TYPE_ADD_DEPENDANT))
						|| ((sourceFile.contains("_mi")
								|| sourceFile.contains("_jc")
								|| sourceFile.contains("_re") || sourceFile
								.contains("_x2")) && ((xRatio < yRatio && ruleTypes
								.contains(TYPE_ADD_MORE_SPECIFIC)) || (yRatio < xRatio && ruleTypes
								.contains(TYPE_ADD_LESS_SPECIFIC))))) {
					addable = seqY;
					addableCount = yCount;
					addableRatio = yRatio;
					indicator = seqX;
					indicatorCount = xCount;
					indicatorRatio = xRatio;
					addableText = line[3];
					indicatorText = line[1];
					if (!checkRanges(properties, dropableCountRange,
							dropableRFRange, indicatorCountRange,
							indicatorRFRange, addableCount, indicatorCount,
							addableRatio, indicatorRatio)) {
						line = reader.readNext();
						continue;
					}
					bw.write(String.format("# ADD %s IF %s\n", addableText,
							indicatorText + " c=" + addableCount, indicatorText
									+ " c=" + indicatorCount + " measure: "
									+ distance + " co-occurrence: " + coCount));
					bw.write(String
							.format("ADD %d IF %d\n", addable, indicator));
				}
				// ///////DROPPING
				int dropable;
				int dropableCount;
				double dropableRatio;
				String dropableText;

				if ((sourceFile.contains("cxy") && ruleTypes
						.contains(TYPE_DROP_DEPENDANT))
						|| (sourceFile.contains("cyx") && ruleTypes
								.contains(TYPE_DROP_PREDICTOR))
						|| ((sourceFile.contains("_mi")
								|| sourceFile.contains("_jc")
								|| sourceFile.contains("_re") || sourceFile
								.contains("_x2")) && ((xRatio < yRatio && ruleTypes
								.contains(TYPE_DROP_LESS_SPECIFIC)) || (yRatio < xRatio && ruleTypes
								.contains(TYPE_DROP_MORE_SPECIFIC))))) {
					dropable = seqX;
					dropableCount = xCount;
					dropableRatio = xRatio;
					indicator = seqY;
					indicatorCount = yCount;
					indicatorRatio = yRatio;
					dropableText = line[1];
					indicatorText = line[3];

					if (!checkRanges(properties, dropableCountRange,
							dropableRFRange, indicatorCountRange,
							indicatorRFRange, dropableCount, indicatorCount,
							dropableRatio, indicatorRatio)) {
						line = reader.readNext();
						continue;
					}

					bw.write(String.format("# DROP %s IF %s AND %s\n",
							dropableText, dropableText + " c=" + dropableCount,
							indicatorText + " c=" + indicatorCount
									+ " measure: " + distance
									+ " co-occurrence: " + coCount));
					bw.write(String.format("DROP %d IF %d AND %d\n", dropable,
							dropable, indicator));
				}
				if ((sourceFile.contains("cxy") && ruleTypes
						.contains(TYPE_DROP_PREDICTOR))
						|| (sourceFile.contains("cyx") && ruleTypes
								.contains(TYPE_DROP_DEPENDANT))
						|| ((sourceFile.contains("_mi")
								|| sourceFile.contains("_jc")
								|| sourceFile.contains("_re") || sourceFile
								.contains("_x2")) && ((xRatio < yRatio && ruleTypes
								.contains(TYPE_DROP_MORE_SPECIFIC)) || (yRatio < xRatio && ruleTypes
								.contains(TYPE_DROP_LESS_SPECIFIC))))) {
					dropable = seqY;
					dropableCount = yCount;
					dropableRatio = yRatio;
					indicator = seqX;
					indicatorCount = xCount;
					indicatorRatio = xRatio;
					dropableText = line[3];
					indicatorText = line[1];
					if (!checkRanges(properties, dropableCountRange,
							dropableRFRange, indicatorCountRange,
							indicatorRFRange, dropableCount, indicatorCount,
							dropableRatio, indicatorRatio)) {
						line = reader.readNext();
						continue;
					}
					bw.write(String.format("# DROP %s IF %s AND %s\n",
							dropableText, dropableText + " c=" + dropableCount,
							indicatorText + " c=" + indicatorCount
									+ " measure: " + distance
									+ " co-occurrence: " + coCount));
					bw.write(String.format("DROP %d IF %d AND %d\n", dropable,
							dropable, indicator));
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
			line = reader.readNext();
		}
		reader.close();
		bw.close();
	}

	/**
	 * Check if the numeric predicates apply for the given co-occurrence counts.
	 * 
	 * @param properties
	 * @param dropableCountRange
	 * @param dropableRFRange
	 * @param indicatorCountRange
	 * @param indicatorRFRange
	 * @param dropableCount
	 * @param indicatorCount
	 * @param dropableRatio
	 * @param indicatorRatio
	 * @return
	 */
	private static boolean checkRanges(ExperimentProperties properties,
			ParseResult dropableCountRange, ParseResult dropableRFRange,
			ParseResult indicatorCountRange, ParseResult indicatorRFRange,
			int dropableCount, int indicatorCount, double dropableRatio,
			double indicatorRatio) {
		boolean result = properties.checkPredicate(dropableCountRange,
				dropableCount)
				&& properties.checkPredicate(dropableRFRange, dropableRatio)
				&& properties.checkPredicate(indicatorCountRange,
						indicatorCount)
				&& properties.checkPredicate(indicatorRFRange, indicatorRatio);
		return result;
	}

}
